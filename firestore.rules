rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * CORE PHILOSOPHY
     * This ruleset implements a strict User-Ownership model complemented by an "Admin Marker" 
     * pattern for high-performance administrative authorization. It prioritizes security 
     * for sensitive patient data while allowing rapid prototyping by being flexible 
     * with data shapes (schema-agnostic) except for critical relational identifiers.
     *
     * DATA STRUCTURE
     * - /users/{userId}: Private user profiles.
     * - /users/{userId}/orders/{orderId}: Private order history nested under the user.
     * - /medicines/{medicineId}: Public inventory available for all authenticated users.
     * - /roles_admin/{adminId}: A marker collection where the existence of a document 
     *   matching a UID grants administrative privileges.
     *
     * KEY SECURITY DECISIONS
     * - Authorization Independence: Admin status is verified using `exists()` on the 
     *   `roles_admin` collection, avoiding expensive `get()` calls on user profiles.
     * - Path-Based Security: Orders are nested under the user's path to allow for 
     *   simple `isOwner` checks and efficient list queries.
     * - Relational Integrity: On document creation, the rules enforce that the `userId` 
     *   field in the data matches the authenticated user's ID and the path ID.
     * - Prototyping Flexibility: General content fields (e.g., names, descriptions, 
     *   quantities) are not type-validated to allow for schema iteration.
     */

    // --- Global Helper Functions ---

    /** Checks if the request is from a signed-in user. */
    function isSignedIn() {
      return request.auth != null;
    }

    /** Checks if the provided ID matches the authenticated user's UID. */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /** 
     * Checks if the authenticated user is an administrator.
     * Uses the existence of a document in the roles_admin collection for speed.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /** Combined check for ownership and document existence for updates/deletes. */
    function isExistingOwner(userId) {
      return resource != null && isOwner(userId);
    }

    /** Combined check for admin status and document existence for updates/deletes. */
    function isExistingAdmin() {
      return resource != null && isAdmin();
    }

    // --- Collection Rules ---

    /**
     * @description Rules for user profiles. Users can manage their own, admins can view all.
     * @path /users/{userId}
     * @allow get, update: (isOwner(userId)), list: (isAdmin())
     * @deny delete: (Always - profile deletion is a restricted administrative action)
     * @principle Enforces path-based ownership for personal data.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if false; // Profiles are preserved for order history integrity.
    }

    /**
     * @description Marker collection for admin roles. Existence of document = Admin status.
     * @path /roles_admin/{adminId}
     * @allow get: (isSignedIn())
     * @deny write, list: (Users cannot modify admin roles)
     * @principle Uses a marker collection to decouple role checks from user profile reads.
     */
    match /roles_admin/{adminId} {
      allow get: if isSignedIn();
      allow list: if isAdmin();
      allow create, update, delete: if false; // Managed via Firebase Console or Backend only.
    }

    /**
     * @description Public medicine inventory. Authenticated users can browse; admins manage stock.
     * @path /medicines/{medicineId}
     * @allow get, list: (isSignedIn())
     * @allow write: (isAdmin())
     * @principle Public-read for inventory with restricted administrative writes.
     */
    match /medicines/{medicineId} {
      allow get, list: if isSignedIn();
      allow create: if isAdmin();
      allow update, delete: if isExistingAdmin();
    }

    /**
     * @description Individual order history. Nested under user for security and performance.
     * @path /users/{userId}/orders/{orderId}
     * @allow get, list, create: (isOwner(userId)), update, delete: (isAdmin())
     * @deny update: (Users cannot change order status once placed)
     * @principle Validates relational integrity by forcing userId in data to match the path.
     */
    match /users/{userId}/orders/{orderId} {
      allow get, list: if isOwner(userId) || isAdmin();
      
      // On create, ensure the user is the owner and the internal userId matches the path.
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      
      // Admins manage status and order fulfillment. Users cannot edit orders once placed.
      allow update: if isExistingAdmin();
      allow delete: if isExistingAdmin();
    }

    /**
     * @description Static role definitions. Used for reference.
     * @path /roles/{roleId}
     * @allow get, list: (isSignedIn())
     * @deny write: (Static reference data)
     * @principle Read-only reference data for role names and descriptions.
     */
    match /roles/{roleId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if false;
    }
  }
}