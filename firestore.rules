rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * CORE PHILOSOPHY:
     * This ruleset implements a robust, multi-tier authorization model designed for a pharmacy application. 
     * It leverages path-based ownership for patient data and role-based access control (RBAC) for 
     * administrative functions.
     *
     * DATA STRUCTURE:
     * - /medicines: Global catalog of pharmaceutical products.
     * - /patients/{patientId}: Private patient profiles.
     * - /patients/{patientId}/orders: Subcollection for order history, nested for path-based security.
     * - /roles_admin/{adminId}: A registry of administrative users.
     *
     * KEY SECURITY DECISIONS:
     * 1. Authorization Independence: We favor path-based checks and denormalized fields (like patientId) 
     *    to ensure rules are performant and do not require excessive get() calls.
     * 2. Existence-Based Roles: Administrative privileges are determined by the presence of a 
     *    document in the /roles_admin collection.
     * 3. Public Read for Catalog: Medicines are readable by any authenticated user to allow the 
     *    AI pharmacist and users to browse inventory.
     *
     * DENORMALIZATION FOR AUTHORIZATION:
     * - The 'patientId' is included within Order documents and matches the path segment. This 
     *   allows rules to verify the creator's identity without querying the parent patient document.
     */

    // --- Helper Functions ---

    /** @description Checks if the user is authenticated. */
    function isSignedIn() {
      return request.auth != null;
    }

    /** @description Checks if the user's UID matches the provided ID. */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /** @description Checks if the user has an entry in the admin roles collection. */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    // The 'isExistingOwner' function was removed as it was unused and contained an invalid variable reference ('resource')
    // when defined as a helper function. Direct use of 'resource != null' in `allow` statements is the standard practice.

    // --- Collection Rules ---

    /**
     * @description Rules for the global medicine inventory.
     * @path /medicines/{medicineId}
     * @allow (get) Authenticated user viewing stock levels.
     * @deny (create) Non-admin user attempting to add a new medicine.
     * @principle Public read for authenticated users; admin-only management.
     */
    match /medicines/{medicineId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Rules for private patient profile documents.
     * @path /patients/{patientId}
     * @allow (get) Patient accessing their own profile details.
     * @deny (list) One patient trying to browse all other patient records.
     * @principle Path-based ownership ensures users only access their own data.
     */
    match /patients/{patientId} {
      allow get, list: if isOwner(patientId) || isAdmin();
      allow create: if isOwner(patientId);
      allow update: if (isOwner(patientId) || isAdmin()) && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Rules for orders placed by patients.
     * @path /patients/{patientId}/orders/{orderId}
     * @allow (create) Patient placing an order where the internal patientId matches their UID.
     * @deny (update) Patient trying to change the patientId of an existing order.
     * @principle Relational integrity check combined with path-based ownership.
     */
    match /patients/{patientId}/orders/{orderId} {
      allow get, list: if isOwner(patientId) || isAdmin();
      
      // Prototyping: Validating only relational integrity fields
      allow create: if isOwner(patientId) && request.resource.data.patientId == patientId;
      
      // Ensure existing data is not modified by unauthorized users and patientId remains immutable
      allow update: if (isOwner(patientId) || isAdmin()) && resource != null && request.resource.data.patientId == resource.data.patientId;
      
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Rules for identifying administrative users.
     * @path /roles_admin/{adminId}
     * @allow (get) User checking if they have admin privileges.
     * @deny (create) User attempting to self-promote to an admin role.
     * @principle Existence-over-content RBAC; management should be external (Console/Admin SDK).
     */
    match /roles_admin/{adminId} {
      allow get: if isOwner(adminId) || isAdmin();
      allow list: if isAdmin();
      
      // CRITICAL: Writing to roles must be restricted to prevent unauthorized privilege escalation.
      // Prototyping note: Generally managed via Firebase Console or Admin SDK.
      allow create, update, delete: if false; 
    }
  }
}