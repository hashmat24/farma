{
  "entities": {
    "Medicine": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Medicine",
      "type": "object",
      "description": "Represents a pharmaceutical medicine with its details, current stock levels, and prescription requirements.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Medicine entity."
        },
        "name": {
          "type": "string",
          "description": "The commercial or generic name of the medicine."
        },
        "dosage": {
          "type": "string",
          "description": "Standard dosage information for the medicine (e.g., '50mg', '1 tablet daily'), used for refill calculations."
        },
        "stockQty": {
          "type": "number",
          "description": "The current quantity of this medicine available in stock."
        },
        "prescriptionRequired": {
          "type": "boolean",
          "description": "Indicates whether a prescription is legally required to dispense this medicine."
        },
        "reorderThreshold": {
          "type": "number",
          "description": "The minimum stock quantity at which a low stock alert should be triggered for this medicine."
        }
      },
      "required": [
        "id",
        "name",
        "dosage",
        "stockQty",
        "prescriptionRequired",
        "reorderThreshold"
      ]
    },
    "Order": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Order",
      "type": "object",
      "description": "Represents a single new order placed by a patient for a specific medicine, tracking its processing and fulfillment status.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Order entity."
        },
        "patientId": {
          "type": "string",
          "description": "Identifier for the patient who placed the order. (Relationship: Patient 1:N Order)"
        },
        "medicineId": {
          "type": "string",
          "description": "Reference to the Medicine that was ordered. (Relationship: Medicine 1:N Order)"
        },
        "quantity": {
          "type": "number",
          "description": "The quantity of the medicine ordered in this transaction."
        },
        "orderDate": {
          "type": "string",
          "description": "The timestamp when the order was placed.",
          "format": "date-time"
        },
        "status": {
          "type": "string",
          "description": "The current processing status of the order (e.g., 'pending', 'dispatched', 'completed', 'failed', 'webhook_failed')."
        },
        "traceId": {
          "type": "string",
          "description": "The Langfuse trace identifier associated with the AI agent's execution for this order."
        },
        "webhookDispatched": {
          "type": "boolean",
          "description": "Indicates if the warehouse fulfillment webhook was successfully triggered for this order."
        },
        "webhookError": {
          "type": "string",
          "description": "Stores any error message if the warehouse fulfillment webhook failed."
        }
      },
      "required": [
        "id",
        "patientId",
        "medicineId",
        "quantity",
        "orderDate",
        "status",
        "traceId",
        "webhookDispatched"
      ]
    },
    "OrderHistory": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "OrderHistory",
      "type": "object",
      "description": "A historical record of patient medicine purchases, primarily used for predictive refill calculations. This entity may contain pre-existing data loaded from a master file or derived from processed orders.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for this specific historical purchase record."
        },
        "patientId": {
          "type": "string",
          "description": "Identifier for the patient associated with this historical purchase. (Relationship: Patient 1:N OrderHistory)"
        },
        "medicineId": {
          "type": "string",
          "description": "Reference to the Medicine that was purchased in this historical record. (Relationship: Medicine 1:N OrderHistory)"
        },
        "orderId": {
          "type": "string",
          "description": "Optional reference to the original Order if this history record originated from a processed order. Can be null for pre-loaded historical data. (Relationship: Order 1:0..1 OrderHistory)"
        },
        "quantityPurchased": {
          "type": "number",
          "description": "The quantity of medicine purchased in this historical record."
        },
        "purchaseDate": {
          "type": "string",
          "description": "The date and time when this historical purchase occurred.",
          "format": "date-time"
        },
        "dosageAtPurchase": {
          "type": "string",
          "description": "The dosage information of the medicine at the time of this historical purchase, critical for accurate refill predictions."
        }
      },
      "required": [
        "id",
        "patientId",
        "medicineId",
        "quantityPurchased",
        "purchaseDate",
        "dosageAtPurchase"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/medicines/{medicineId}",
        "definition": {
          "entityName": "Medicine",
          "schema": {
            "$ref": "#/backend/entities/Medicine"
          },
          "description": "Stores details and stock levels for all pharmaceutical medicines. Designed for public read access to support inventory display, with write operations restricted to administrators. No specific denormalization for authorization is required within the document itself, as access is global or role-based.",
          "params": [
            {
              "name": "medicineId",
              "description": "The unique identifier of the medicine."
            }
          ]
        }
      },
      {
        "path": "/users/{patientId}/orders/{orderId}",
        "definition": {
          "entityName": "Order",
          "schema": {
            "$ref": "#/backend/entities/Order"
          },
          "description": "Represents a single order placed by a patient. This subcollection is owned by the respective patient. The 'patientId' field within each document denormalizes the ownership context, enabling authorization independence by matching 'request.auth.uid' with the path parameter and document field.",
          "params": [
            {
              "name": "patientId",
              "description": "The unique identifier of the patient who owns this order (matches request.auth.uid for secure access)."
            },
            {
              "name": "orderId",
              "description": "The unique identifier for this specific order."
            }
          ]
        }
      },
      {
        "path": "/users/{patientId}/orderHistory/{historyId}",
        "definition": {
          "entityName": "OrderHistory",
          "schema": {
            "$ref": "#/backend/entities/OrderHistory"
          },
          "description": "Stores a historical record of medicine purchases for a specific patient. This subcollection is owned by the respective patient. The 'patientId' field within each document denormalizes the ownership context, enabling authorization independence by matching 'request.auth.uid' with the path parameter and document field, crucial for predictive refill calculations.",
          "params": [
            {
              "name": "patientId",
              "description": "The unique identifier of the patient to whom this order history record belongs (matches request.auth.uid for secure access)."
            },
            {
              "name": "historyId",
              "description": "The unique identifier for this specific historical purchase record."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure for CuraCare AI is designed to be secure, scalable, and debuggable by strictly adhering to the core design principles. This involves strategic pathing, denormalization of authorization context, and clear segregation of data.\n\n**Authorization Independence (CRITICAL):**\nThis design prioritizes authorization independence to eliminate `get()` calls within security rules and enable atomic operations. \n*   **User-Specific Data (`Order`, `OrderHistory`):** For all patient-owned data, a hierarchical path structure `/users/{patientId}/<collectionName>/{documentId}` is used. Each `Order` and `OrderHistory` document includes a `patientId` field, which is denormalized directly into the document itself and matches the `{patientId}` wildcard in the path. This allows security rules to directly compare `request.auth.uid` with the `patientId` in the document or the path, e.g., `request.auth.uid == patientId` or `request.auth.uid == resource.data.patientId`. This eliminates any need to `get()` a parent `User` document to verify ownership.\n*   **Global Data (`Medicine`):** The `/medicines` collection is a top-level collection. Its authorization (public read, admin write) is self-contained and does not depend on data from other collections via `get()` calls.\n*   **Global Roles (Admin):** While not explicitly listed in `firestorePaths` due to schema constraints, administrative roles are conceptually managed via a dedicated top-level collection, `/roles_admin/{uid}`. An admin's authorization would be determined by the mere existence of a document at `/roles_admin/$(request.auth.uid)`. This 'existence over content' approach ensures role checks are simple and atomic, avoiding complex `get()` operations on user profiles.\n\n**QAPs (Rules are not Filters):**\nThis structure enables secure and efficient `list` operations:\n*   **Global Inventory (`/medicines`):** This collection is designed for public read access, supporting the `GET /inventory` endpoint. Rules can permit all authenticated and unauthenticated users to `list` documents in this collection, ensuring the client retrieves only what it's authorized to see (which is all items).\n*   **Patient-Specific Data (`/users/{patientId}/orders`, `/users/{patientId}/orderHistory`):** For patient-specific data such as orders and order history (supporting `GET /user-history/{patient}` and `GET /refill-alerts`), the path-based ownership is key. Security rules will enforce `allow list: if request.auth.uid == patientId;`. This ensures that a user can only `list` documents within their own `/users/{patientId}` subcollections, preventing data leakage and enabling efficient queries without the need for client-side filtering or inefficient database scans based on permissions.\n\n**Structural Segregation & Access Modeling:**\n*   **Homogeneous Security Posture:** Each collection or subcollection maintains a homogeneous security posture. `/medicines` is globally readable. `/users/{patientId}/orders` and `/users/{patientId}/orderHistory` are strictly owned by the respective patient (or accessible by an administrator).\n*   **Path-Based Ownership:** The `/users/{patientId}/` prefix consistently identifies data belonging to a specific patient, making ownership-based rules straightforward.\n*   **Global Roles:** Administrative access, crucial for `POST /update-inventory` and `GET /admin/dashboard`, is managed by checking for the existence of documents in a dedicated `/roles_admin` collection.\n\n**Data Clarity and Predictability:**\n*   **Explicit State Modeling:** The `Order` entity uses a clear `status` field (e.g., 'pending', 'dispatched') for explicit state management. \n*   **Predictable Schema:** Fields like `patientId`, `medicineId`, and `ownerId` are consistently named and used for authorization and relationships.\n*   **Radical Consistency:** Wildcards are descriptive (e.g., `{patientId}`, `{medicineId}`)."
  }
}